<!DOCTYPE html>
<meta charset="utf-8" />
<title>Test Suite</title>
<link rel="stylesheet" href="./node_modules/qunit/qunit/qunit.css" />
<body>
  <div id="qunit"></div>

  <div id="qunit-fixture">
    <div id="test-parent">
      <div id="test-child"></div>
    </div>
  </div>

  <script src="./node_modules/qunit/qunit/qunit.js"></script>

  <style>
    #qunit-fixture {
      position: static;
    }

    #test-parent {
      background-color: red;
      width: 100px;
      height: 100px;
    }

    #test-child {
      background-color: blue;
      width: 50px;
      height: 50px;
    }

    #test-parent,
    #test-child {
      position: absolute;
      transition-property: margin-left, transform;
      transition-duration: 500ms;
      animation-duration: 500ms;
    }

    .animate {
      animation-name: move-right, move-down;
    }

    .transition {
      margin-left: 100px;
      transform: translateY(100px);
    }

    @keyframes move-right {
      from {
        margin-left: 0;
      }

      to {
        margin-left: 100px;
      }
    }

    @keyframes move-down {
      from {
        transform: translateY(0);
      }

      to {
        transform: translateY(100px);
      }
    }
  </style>

  <script>
    async function waitForAnimation(element, options = {}) {
      await waitForFrame();

      return Promise.all(
        element
          .getAnimations({
            subtree: options.subtree
          })
          .filter((animation) => {
            if (options.transitionProperty) {
              return (
                animation.transitionProperty === options.transitionProperty
              );
            }

            if (options.animationName) {
              return animation.animationName === options.animationName;
            }

            return true;
          })
          .map((animation) => {
            return animation.finished.catch(() => {
              // squelch aborted animations
            });
          })
      );
    }

    function waitForFrame() {
      return new Promise(window.requestAnimationFrame);
    }
  </script>

  <script>
    const { test, module } = QUnit;
    const { isArray } = Array;

    function keyForAnimation(animation) {
      return animation instanceof CSSAnimation
        ? 'animationName'
        : 'transitionProperty';
    }

    QUnit.assert.animated = function (actual, expected) {
      this.pushResult({
        result: actual.reduce((result, animation, index) => {
          return (
            result &&
            animation.playState === 'finished' &&
            animation.effect.target === expected[index][0] &&
            animation[keyForAnimation(animation)] === expected[index][1]
          );
        }, actual.length === expected.length),

        expected: actual.map((animation) => {
          return [
            animation.effect.target,
            animation[keyForAnimation(animation)]
          ];
        })
      });
    };

    module('waitForAnimation', function (hooks) {
      hooks.beforeEach(async function () {
        this.parent = document.getElementById('test-parent');
        this.child = document.getElementById('test-child');
        this.parent.className = '';
        this.child.className = '';

        await waitForFrame();
      });

      test('css animations', async function (assert) {
        assert.expect(1);

        this.parent.classList.add('animate');

        const animations = await waitForAnimation(this.parent);

        assert.animated(animations, [
          [this.parent, 'move-right'],
          [this.parent, 'move-down']
        ]);
      });

      test('a specific css animation', async function (assert) {
        assert.expect(1);

        this.parent.classList.add('animate');

        const animations = await waitForAnimation(this.parent, {
          animationName: 'move-down'
        });

        assert.animated(animations, [[this.parent, 'move-down']]);
      });

      test('css transitions', async function (assert) {
        assert.expect(1);

        this.parent.classList.add('transition');

        const animations = await waitForAnimation(this.parent);

        assert.animated(animations, [
          [this.parent, 'margin-left'],
          [this.parent, 'transform']
        ]);
      });

      test('a specific css transition', async function (assert) {
        assert.expect(1);

        this.parent.classList.add('transition');

        const animations = await waitForAnimation(this.parent, {
          transitionProperty: 'transform'
        });

        assert.animated(animations, [[this.parent, 'transform']]);
      });

      test('js animations', async function (assert) {
        assert.expect(1);

        this.parent.animate(
          [
            { marginLeft: 0, transform: 'translateY(0px)' },
            { marginLeft: '100px', transform: 'translateY(100px)' }
          ],
          {
            duration: 500
          }
        );

        const animations = await waitForAnimation(this.parent);

        assert.animated(animations, [[this.parent, undefined]]);
      });

      test('child animations', async function (assert) {
        assert.expect(1);

        this.child.classList.add('animate');

        const animations = await waitForAnimation(this.parent, {
          subtree: true
        });

        assert.animated(animations, [
          [this.child, 'move-right'],
          [this.child, 'move-down']
        ]);
      });

      test('a specific child animation', async function (assert) {
        assert.expect(1);

        this.child.classList.add('animate');

        const animations = await waitForAnimation(this.parent, {
          subtree: true,
          animationName: 'move-down'
        });

        assert.animated(animations, [[this.child, 'move-down']]);
      });

      test('a specific child transition', async function (assert) {
        assert.expect(1);

        this.child.classList.add('transition');

        const animations = await waitForAnimation(this.parent, {
          subtree: true,
          transitionProperty: 'transform'
        });

        assert.animated(animations, [[this.child, 'transform']]);
      });

      test('multiple animations', async function (assert) {
        assert.expect(1);

        this.child.classList.add('transition');
        this.parent.classList.add('animate');

        const animations = await waitForAnimation(this.parent, {
          subtree: true
        });

        assert.animated(animations, [
          [this.child, 'margin-left'],
          [this.child, 'transform'],
          [this.parent, 'move-right'],
          [this.parent, 'move-down']
        ]);
      });

      test('aborted transitions', async function (assert) {
        assert.expect(0);

        this.parent.classList.add('transition');

        const promise = waitForAnimation(this.parent);

        await waitForFrame();

        this.parent.classList.remove('transition');

        await promise;
      });

      test('animation not started yet', async function (assert) {
        assert.expect(1);

        const promise = waitForAnimation(this.parent);

        this.parent.classList.add('animate');

        const animations = await promise;

        assert.animated(animations, [
          [this.parent, 'move-right'],
          [this.parent, 'move-down']
        ]);
      });

      test('animation not started yet (does not use events system)', async function (assert) {
        assert.expect(1);

        const promise = waitForAnimation(this.parent);

        setTimeout(() => {
          this.parent.classList.add('animate');
        }, 100);

        const animations = await promise;

        assert.animated(animations, []);
      });

      test('no animation does not result in a never ending promise', async function (assert) {
        assert.expect(1);
        assert.timeout(1000);

        const animations = await waitForAnimation(this.parent);

        assert.animated(animations, []);
      });

      test('thenable', function (assert) {
        assert.expect(1);

        this.parent.classList.add('animate');

        return waitForAnimation(this.parent).then((animations) => {
          assert.animated(animations, [
            [this.parent, 'move-right'],
            [this.parent, 'move-down']
          ]);
        });
      });
    });
  </script>
</body>
